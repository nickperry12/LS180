/*

Write a SQL query that shows all items that have had bids put on them. Use the
logical operator IN for this exercise, as well as a subquery.

Here is the expected output:

Copy Code
 Bid on Items
---------------
 Video Game
 Outdoor Grill
 Painting
 Tent
 Vase
(5 rows)

Algo:

Need to select the title of the item and set the alias a "Bid on Items".
We only want to select the items that have at least one bid on them. This data
is contained in the `bids` table. Essentially, we can say that if the item is in
the `bids` table, we want to select it.

We have to use the logical `IN` operator to accomplish this. 

*/

SELECT i.name AS "Bids on Items"
FROM items AS i
WHERE i.id IN
  (SELECT b.item_id FROM bids AS b);

/*

Write a SQL query that shows all items that have not had bids put on them. Use
the logical operator NOT IN for this exercise, as well as a subquery.

Here is the expected output:

Copy Code
 Not Bid On
------------
 Television
(1 row)

Algo:

We want to do the same thing as the previous query. But, the difference this
time is that we want to select the ids that are not in the returned list of ids
from the subquery. We must use the `NOT IN` operator.

*/

SELECT i.name AS "Not Bid On"
FROM items AS i
WHERE i.id NOT IN
  (SELECT b.item_id FROM bids AS b);

/*

Write a SELECT query that returns a list of names of everyone who has bid in the
auction. While it is possible (and perhaps easier) to do this with a JOIN
clause, we're going to do things differently: use a subquery with the EXISTS
clause instead. Here is the expected output:

      name
-----------------
 Alison Walker
 James Quinn
 Taylor Williams
 Alexis Jones
 Gwen Miller
 Alan Parker
(6 rows)

Algo:

In this problem we want to select the names of the people who have bid on an
item.

Select names from the `bidders` table where the `id` of the person who bid on an
item exists in the table `bids`.
- The `id` from `bidders` must match the `bidder_id` from `bids`

*/

SELECT b.name
FROM bidders AS b
WHERE EXISTS (SELECT bi.bidder_id FROM bids AS bi WHERE bi.bidder_id = b.id);

/* 

For this exercise, we'll make a slight departure from how we've been using
subqueries. We have so far used subqueries to filter our results using a WHERE
clause. In this exercise, we will build that filtering into the table that we
will query. Write an SQL query that finds the largest number of bids from an
individual bidder.

For this exercise, you must use a subquery to generate a result table (or
transient table), and then query that table for the largest number of bids.

Your output should look like this:

Copy Code
  max
------
    9
(1 row)
Approach/Algorithm

Algo:

Our subquery table should generate a result/transient table that contains
the counted number of bids for each person. The outer query should then select
from this transient table the highest number of bids placed by one person.

For the subquery:

Select the count of user ids, and group by the user ids

For the outer query:

Select the maximum count of bids from the table generated by the subquery

*/

SELECT max(counts."count") FROM
  (SELECT count(bi.bidder_id) AS "count" FROM bids AS bi GROUP BY bi.bidder_id) AS counts;

/*

For this exercise, use a scalar subquery to determine the number of bids on each
item. The entire query should return a table that has the name of each item
along with the number of bids on an item.

Here is the expected output:

Copy Code
    name      | count
--------------+-------
Video Game    |     4
Outdoor Grill |     1
Painting      |     8
Tent          |     4
Vase          |     9
Television    |     0
(6 rows)

Algo:

A scalar subquery is a subquery that returns a single value.

We want to determine the number of bids on each item. Our table should return
two columns `name` and `count`.

Select `name` from `items` table
Select `count` from `bids` table where the item id from `bids` matches the item
id from `items`

Note: we're basically using a subquery to create a column

*/

SELECT i.name, (SELECT count(bi.item_id) FROM bids AS bi WHERE bi.item_id = i.id) AS count
FROM items AS i;

/*

We want to check that a given item is in our database. There is one problem
though: we have all of the data for the item, but we don't know the id number.
Write an SQL query that will display the id for the item that matches all of the
data that we know, but does not use the AND keyword. Here is the data we know:

'Painting', 100.00, 250.00

Algo:

Select id from items
Where the item id 

*/

SELECT id FROM items
WHERE ROW(name, initial_price, sales_price) = ROW('Painting', 100.00, 250.00);

/*

For this exercise, let's explore the EXPLAIN PostgreSQL statement. It's a very
useful SQL statement that lets us analyze the efficiency of our SQL statements.
More specifically, use EXPLAIN to check the efficiency of the query statement we
used in the exercise on EXISTS:

SELECT name FROM bidders
WHERE EXISTS (SELECT 1 FROM bids WHERE bids.bidder_id = bidders.id);

First use just EXPLAIN, then include the ANALYZE option as well. For your
answer, list any SQL statements you used, along with the output you get back,
and your thoughts on what is happening in both cases.

*/

SELECT name FROM bidders
WHERE EXISTS (SELECT 1 FROM bids WHERE bids.bidder_id = bidders.id);

EXPLAIN SELECT name FROM bidders
WHERE EXISTS (SELECT 1 FROM bids WHERE bids.bidder_id = bidders.id);
                                QUERY PLAN
--------------------------------------------------------------------------
 Hash Join  (cost=33.38..62.84 rows=635 width=32)
   Hash Cond: (bidders.id = bids.bidder_id)
   ->  Seq Scan on bidders  (cost=0.00..22.70 rows=1270 width=36)
   ->  Hash  (cost=30.88..30.88 rows=200 width=4)
         ->  HashAggregate  (cost=28.88..30.88 rows=200 width=4)
               Group Key: bids.bidder_id
               ->  Seq Scan on bids  (cost=0.00..25.10 rows=1510 width=4)
(7 rows)

EXPLAIN ANALYZE SELECT name FROM bidders
WHERE EXISTS (SELECT 1 FROM bids WHERE bids.bidder_id = bidders.id);
                                                    QUERY PLAN
-----------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=33.38..62.84 rows=635 width=32) (actual time=0.083..0.088 rows=6 loops=1)
   Hash Cond: (bidders.id = bids.bidder_id)
   ->  Seq Scan on bidders  (cost=0.00..22.70 rows=1270 width=36) (actual time=0.018..0.021 rows=7 loops=1)
   ->  Hash  (cost=30.88..30.88 rows=200 width=4) (actual time=0.040..0.040 rows=6 loops=1)
         Buckets: 1024  Batches: 1  Memory Usage: 9kB
         ->  HashAggregate  (cost=28.88..30.88 rows=200 width=4) (actual time=0.031..0.032 rows=6 loops=1)
               Group Key: bids.bidder_id
               ->  Seq Scan on bids  (cost=0.00..25.10 rows=1510 width=4) (actual time=0.009..0.014 rows=26 loops=1)
 Planning time: 0.222 ms
 Execution time: 0.161 ms
(10 rows)

/*

EXPLAIN is used to show statistics about the query plan for a SQL statement.
Here is the general form for EXPLAINs syntax:

EXPLAIN sql_expression;

Let's go through the output of each EXPLAIN statement and see what is going on.

The first EXPLAIN statement contains a fair amount of information. Each row
represents an operation taken. The following items are listed in each row of
information.

The name of the node used to perform the SQL statement. A node represents some
operation taken to run the SQL statement. An example would be the name in the
first row of our query plan, Hash Join The estimated startup cost and estimated
total cost. These can be seen here: Hash Join (cost=33.38..62.84 rows=635
width=32) The first number after cost is the estimated startup cost, and the
second is the estimated total cost. The estimated number of rows to be shown
when the SQL statement we are explaining is run. This is the number right after
rows= above. The width is the estimated amount in bytes taken up by rows for the
SQL statement we are explaining. Did you notice how some nodes are nested
further in than others? A nested node represents one that is a child of the one
above it. That means that nested nodes were operations necessary to allow the
parent node(operation) to run its course. One other important fact is that all
of these numbers represent estimates. The SQL statement we're explaining isn't
actually run, so all information listed above is an approximation of what will
actually happen. Another thing to consider are the units used for describing the
estimated startup and total costs. These units are arbitrary and are used by
PostgreSQL internally to create the query plan. Their main purpose is to give
some measure of the efficiency of using certain nodes, taking certain operations
to execute a SQL statement. If the cost is greater than some other group of
operations then it will probably be dropped for an alternative approach.

Next, let's take a look at the information that was added when we used the
ANALYZE option. The information here is mostly the same: cost, rows, and width
are still there. But there is one other bit of information that has been added
to each node: the actual_time required for the startup and execution of that
node. At the end of our query plan, the planning and execution time have also
been added: these represent the total time required to set up the SQL statement
along with the total time it took to execute that SQL statement.

Since the SQL statement is actually run when we use EXPLAIN ANALYZE, the results
we get from our query plan are the actual results, and not estimates; that
includes the costs and the measures of time elapsed per operation.

Now, one might wonder why bother with the EXPLAIN statement at all? Well, this
statement can actually be really useful. We can compare the costs of running
different SQL statements, which can help us with optimizing our DB calls. There
may be some SQL statements that we don't actually want to run, but just want
some estimated data on: in that case, use EXPLAIN. But, if we're ok with running
the statement, and we need some extra data(maybe to compare the elapsed
execution and setup time between two equivalent SQL statements), then we should
use EXPLAIN ANALYZE.

We've been talking about runtimes and optimizing for efficiency between SQL
statements. And now that you're a bit better equipped to understand how EXPLAIN
works, you can try using it. The next exercise will focus on doing just that.

*/

/*

In this exercise, we'll use EXPLAIN ANALYZE to compare the efficiency of two SQL
statements. These two statements are actually from the "Query From a Virtual
Table" exercise in this set. In that exercise, we stated that our subquery-based
solution:

SELECT MAX(bid_counts.count) FROM
  (SELECT COUNT(bidder_id) FROM bids GROUP BY bidder_id) AS bid_counts;


was actually faster than the simpler equivalent without subqueries:


SELECT COUNT(bidder_id) AS max_bid FROM bids
  GROUP BY bidder_id
  ORDER BY max_bid DESC
  LIMIT 1;


In this exercise, we will demonstrate this fact.

Run EXPLAIN ANALYZE on the two statements above. Compare the planning time,
execution time, and the total time required to run these two statements. Also
compare the total "costs". Which statement is more efficient and why?

*/

auction=# EXPLAIN ANALYZE SELECT MAX(bid_counts.count) FROM
auction-#   (SELECT COUNT(bidder_id) FROM bids GROUP BY bidder_id) AS bid_counts;
                                                 QUERY PLAN
------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=1.97..1.98 rows=1 width=8) (actual time=0.027..0.028 rows=1 loops=1)
   ->  HashAggregate  (cost=1.39..1.65 rows=26 width=12) (actual time=0.023..0.025 rows=6 loops=1)
         Group Key: bids.bidder_id
         ->  Seq Scan on bids  (cost=0.00..1.26 rows=26 width=4) (actual time=0.009..0.011 rows=26 loops=1)
 Planning Time: 0.087 ms
 Execution Time: 0.060 ms
(6 rows)

auction=# EXPLAIN ANALYZE SELECT COUNT(bidder_id) AS max_bid FROM bids
auction-#   GROUP BY bidder_id
auction-#   ORDER BY max_bid DESC
auction-#   LIMIT 1;
                                                    QUERY PLAN
------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1.78..1.78 rows=1 width=12) (actual time=0.063..0.064 rows=1 loops=1)
   ->  Sort  (cost=1.78..1.84 rows=26 width=12) (actual time=0.062..0.062 rows=1 loops=1)
         Sort Key: (count(bidder_id)) DESC
         Sort Method: top-N heapsort  Memory: 25kB
         ->  HashAggregate  (cost=1.39..1.65 rows=26 width=12) (actual time=0.034..0.036 rows=6 loops=1)
               Group Key: bidder_id
               ->  Seq Scan on bids  (cost=0.00..1.26 rows=26 width=4) (actual time=0.009..0.013 rows=26 loops=1)
 Planning Time: 0.159 ms
 Execution Time: 0.197 ms
(9 rows)

/*

The first select statement has a lower total cost than the second statement, as
well as shorter planning and execution times. This demonstrates that the first
statement is more efficient than the second statement, despite using a subquery.
There are less nodes in the first statement, which attributes to it being more
efficient as each node represents an operation that is necessary to run the SQL
statement.

*/
